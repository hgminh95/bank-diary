#!/usr/bin/env python3

import cmd

from bank_diary.parser.dbs import DbsParser
from bank_diary.common.db import SQLiteDatabase
import bank_diary.common.stats as stats
import bank_diary.common.syntax as syntax

from bank_diary.defaults import classifier


class DiaryShell(cmd.Cmd):
    intro = 'Welcome to bdiary shell. Type help or ? to list commands.\n'
    prompt = '(diary) '

    def __init__(self):
        super().__init__()

        self.db = SQLiteDatabase()

    def do_load(self, args):
        'specify path to database'
        path = args
        if path.endswith('.py'):
            import importlib.util
            spec = importlib.util.spec_from_file_location('custom', path)
            custom = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(custom)

            global classifier
            classifier = custom.classifier
        else:
            self.db = SQLiteDatabase(db_path)

    def do_import(self, args):
        'import data'
        csv_file = args

        self.db.insert_bulk([t for t in DbsParser().parse_file(csv_file)])

    def do_i(self, args):
        'import data'
        self.do_import(args)

    def do_list(self, args):
        'list all transaction in a specific period'
        prefix = args
        if prefix == 'all':
            prefix = ''

        records = self.db.select_period(prefix)
        print("Found {} transactions.".format(len(records)))

        for rec in records:
            print("> {}".format(rec))

    def do_l(self, args):
        'list all transaction in a specific period'
        self.do_list(args)

    def do_count(self, args):
        'count all transaction in a specific period'
        prefix = args
        if prefix == 'all':
            prefix = ''

        records = self.db.select_period(prefix)
        print("Found {} transactions.".format(len(records)))

    def do_c(self, args):
        'count all transaction in a specific period'
        self.do_count(args)

    def do_get(self, args):
        '''Syntax: get <target> by <group_by> [at <period>]
        '''
        args = args.split(' ')

        syntax.expect_str(args[0])
        syntax.expect_str(args[1], 'by')
        syntax.expect_str(args[2])
        if len(args) == 3:
            args.extend(['at', ''])
        syntax.expect_str(args[3], 'at')
        syntax.expect_str(args[4])

        target = args[0]
        group_by = args[2]
        period = args[4]

        records = self.db.select_period(period)
        for rec in records:
            rec.category = classifier.classify(rec)

        print(stats.aggregate(records, target, group_by))

    def do_exit(self, args):
        'exit'
        return True

    def do_quit(self, args):
        'exit'
        return True

    def do_q(self, args):
        'exit'
        return True


if __name__ == '__main__':
    DiaryShell().cmdloop()
